A) P(xs) -> head (scanr f e xs) = foldr f e xs
    Base Case: P([])
        Left:
            head (scanr f e [])
            = {scanr.1}
            head [e]
            = {head.2}
            e
        Right:
            foldr f e []
            = {foldr.1}
            e
    Inductive Case: P(x:xs)
        Left:
            head (scanr f e (x:xs))
            = {scanr.2}
            head (f x (foldr f e xs): scanr f e xs)
            = {head.2}
            f x (foldr f e xs)
        Right:
            foldr f e (x:xs)
            = {foldr.2}
            f x (foldr f e xs)

B) P(x) -> add x y = add2 x y
    Base Case: P(Zero)
        Left:
            add Zero y
            = {add.2}
            y
        Right:
            add2 Zero y
            = {add2.2}
            y
    Inductive Case: P(Suc x)
        Left:
            add (Suc x) y
            = {add.1}
            Suc (add x y)
        Right:
            add2 (Suc x) y
            = {add2.1}
            add x (Suc y)
            = {canvas announcement proof}
            add (Suc y) x
            = {add.1}
            Suc (add y x)
            = {canvas announcement proof}
            Suc (add x y)

C) P(xs) -> length (xs ++ ys) = add (length xs) (length ys)
   Base Case: P([])
        Left: 
            length ([] ++ ys)
            = {++.1}
            length ys
        Right:
            add (length []) (length ys)
            = {length.1}
            add Zero (length ys)
            = {add.2}
            length ys
    Inductive Case: P(x:xs)
        Left:
            length ((x:xs) ++ ys)
            = {++.2}
            length (x:(xs ++ ys))
            = {length.2}
            Suc (length (xs ++ ys))
        Right:
            add (length (x:xs)) (length ys)
            = {length.2}
            add (Suc (length xs)) (length ys)
            = {add.1}
            Suc (add (length xs) (length ys))
            = {induction hypothesis P(xs)}
            Suc (length (xs ++ ys))

D) P(xs) -> For all ys -> reverse xs ++ ys = foldl (flip (:)) ys xs
    Base Case: P([])
        Left:
            reverse [] ++ ys
            = {reverse.1}
            [] ++ ys
            = {++.1}
            ys
        Right:
            foldl (flip (:)) ys []
            = {foldl.1}
            ys
    
    Inductive Case: P(x:xs)
        Left:
            reverse (x:xs) ++ ys
            = {reverse.2}
            (reverse xs ++ [x]) ++ ys
            = {Lecture 6, Slide 15}
            reverse xs ++ ([x] ++ ys)
            = {definition of :}
            reverse xs ++ ((x:[]) ++ ys)
            = {++.2}
            reverse xs ++ x:([] ++ ys)
            = {++.1}
            reverse xs ++ (x:ys)
        Right:
            foldl (flip (:)) ys (x:xs)
            = {foldl.2}
            foldl (flip (:)) ((flip (:)) ys x) xs
            = {flip.1}
            foldl (flip (:)) (x:ys) xs
            = {induction hypothesis}
            reverse xs ++ (x:ys)

E) P(x) -> evaluate f (Add x y) = evaluate f (Add y x)
        Left:
            evaluate f (Add x y)
            = {evaluate.2}
            add (evaluate f x) (evaluate f y)
        Right:
            evaluate f (Add y x)
            = {evaluate.2}
            add (evaluate f y) (evaluate f x)
            = {canvas announcement}
            add (evaluate f x) (evaluate f y)

F) P(x) -> (evaluate f . replace g) x = evaluate (f . g) x
    Base Case: P(Const x)
        Left:


I) In order for part A to apply to all xs, we must consider the case where xs is undefined.


